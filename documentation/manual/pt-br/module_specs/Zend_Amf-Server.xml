<?xml version="1.0" encoding="UTF-8"?>
<!-- EN-Revision: 24249 -->
<!-- Reviewed: no -->
<sect1 id="zend.amf.server">
    <title>Zend_Amf_Server</title>

    <para>
        <classname>Zend_Amf_Server</classname> fornece um servidor no estilo <acronym>RPC</acronym>
        para manipular requisições feitas com Adobe Flash Player usando o protocolo 
        <acronym>AMF</acronym>. Como todas as classes de servidor do Zend Framework, ela segue a
        <acronym>API</acronym> SoapServer, fornecendo uma interface fácil de lembrar para criar
        servidores.
    </para>

    <example id="zend.amf.server.basic">
        <title>Servidor AMF Básico</title>
        <para>
            Vamos assumir que você tenha criado uma classe <classname>Foo</classname> com uma
            variedade de métodos públicos. Você pode criar um servidor <acronym>AMF</acronym> usando
            o código a seguir:
        </para>

        <programlisting language="php"><![CDATA[
$server = new Zend_Amf_Server();
$server->setClass('Foo');
$response = $server->handle();
echo $response;
]]></programlisting>

        <para>
            Alternativamente, você pode optar por atribuir uma simples função como chamada de
            retorno:
        </para>

        <programlisting language="php"><![CDATA[
$server = new Zend_Amf_Server();
$server->addFunction('myUberCoolFunction');
$response = $server->handle();
echo $response;
]]></programlisting>

        <para>
            Você também pode misturar e combinar várias classes e funções. Quando fizer isso,
            sugerimos que utilize namespaces para que nenhuma colisão de nomes de métodos ocorra;
            isso pode ser feito simplesmente passando uma string como segundo argumento, tanto para
            <methodname>addFunction()</methodname> ou <methodname>setClass()</methodname>.
        </para>

        <programlisting language="php"><![CDATA[
$server = new Zend_Amf_Server();
$server->addFunction('myUberCoolFunction', 'my')
       ->setClass('Foo', 'foo')
       ->setClass('Bar', 'bar');
$response = $server->handle();
echo $response;
]]></programlisting>

        <para>
            O <classname>Zend_Amf_Server</classname> também permite que serviços sejam
            dinamicamente carregados baseado em um caminho de diretório fornecido. Você pode
            adicionar tantos quantos diretórios desejar ao servidor. A ordem em que você adiciona os
            diretórios ao servidor será a ordem em que a pesquisa <acronym>LIFO</acronym> será
            realizada nos diretórios para encontrar a classe. Adição de diretórios é feita com
            o método <methodname>addDirectory()</methodname>.
        </para>

        <programlisting language="php"><![CDATA[
$server->addDirectory(dirname(__FILE__) .'/../services/');
$server->addDirectory(dirname(__FILE__) .'/../package/');
]]></programlisting>

        <para>
            Ao chamar serviços remotos, os nomes de seus fontes podem conter sublinhados ("_") e
            pontos (".") como delimitadores de diretórios. Quando um sublinhado é usado, as
            conveções <acronym>PEAR</acronym> e Zend Framework para nomenclaturas serão respeitadas.
            Isso significa que se você chamar um serviço <filename>com_Foo_Bar</filename> o servidor
            procurará pelo arquivo <filename>Bar.php</filename> em cada caminho incluído em
            <filename>com/Foo/Bar.php</filename>. Se a notação de ponto é usada para seu serviço
            remoto como em <filename>com.Foo.Bar</filename>, <filename>com/Foo/Bar.php</filename>
            será adicionado ao final de cada caminho incluído para autocarregar
            <filename>Bar.php</filename>
        </para>

        <para>
            Todas as requisições <acronym>AMF</acronym> enviadas ao script serão manipuladas
            posteriormente pelo servidor, e uma resposta <acronym>AMF</acronym> será retornada.
        </para>
    </example>

    <note>
        <title>
            Todas as Funções e Métodos atribuídos precisam de Blocos de Documentação (Docblocks)
        </title>

        <para>
            Como todos os componentes de servidor no Zend Framework, você precisa documentar seus
            métodos de classe usando docblocks <acronym>PHP</acronym>. Você precisa fornecer,
            no mínimo, anotações para cada argumento obrigatório assim como o valor de retorno.
            Exemplo:
        </para>

        <programlisting language="php"><![CDATA[
// Função para atribuição:

/**
 * @param  string $name
 * @param  string $greeting
 * @return string
 */
function helloWorld($name, $greeting = 'Hello')
{
    return $greeting . ', ' . $name;
}
]]></programlisting>

        <programlisting language="php"><![CDATA[
// Classe atribuída

class World
{
    /**
     * @param  string $name
     * @param  string $greeting
     * @return string
     */
    public function hello($name, $greeting = 'Hello')
    {
        return $greeting . ', ' . $name;
    }
}
]]></programlisting>

        <para>
            Outras anotações podem ser usadas, mas serão ignoradas.
        </para>
    </note>

    <sect2 id="zend.amf.server.flex">
        <title>Conectando ao servidor com Flex</title>

        <para>
            Conectar a seu <classname>Zend_Amf_Server</classname> a partir de seu projeto Flex é 
            bem simples; você simplesmente precisa apontar sua <acronym>URI</acronym> de ponto de
            extremidade (endpoint) para seu script <classname>Zend_Amf_Server</classname>
        </para>

        <para>
            Digamos, por exemplo, que você tenha criado seu servidor e o colocado no arquivo
            <filename>server.php</filename> na raiz de sua aplicação, e seu <acronym>URI</acronym> é
            <filename>http://example.com/server.php</filename>. Neste caso, você modificaria seu
            arquivo <filename>services-config.xml</filename> para definir o atributo uri de ponto de
            extremidade, <property>channel</property>, para este valor.
        </para>

        <para>
            Se você nunca criou um arquivo <filename>services-config.xml</filename> você poderá
            fazê-lo abrindo seu projeto na janela 'Navigator' do Flex Builder. Clique com o botão
            direito sobre nome do projeto e selecione 'properties'. Na janela de diálogo de
            propriedades do projeto vá para o menu 'Flex Build Path', aba 'Library path' e tenha
            certeza de que o arquivo '<filename>rpc.swc</filename>' foi adicionado aos caminhos de
            seus projetos e pressione 'Ok' para fechar a janela.
        </para>

        <para>
            Você também precisará informar ao compilador para usar o arquivo
            <filename>services-config.xml</filename> para encontrar o ponto de extremidade do
            <classname>RemoteObject</classname>. Para isso, abra novamente o painel de propriedades
            de seu projeto clicando com o botão direito do mouse no diretório do projeto a partir
            da janela 'Navigator' e selecionando 'properties'. Na popup de propriedades selecione
            'Flex COmpiler' e adicione a seqüência de caracteres:
            <command>-services "services-config.xml"</command>. Pressione 'Apply' e depois 'OK' para
            voltar e atualizar a opção. O que você acabou de fazer foi dizer ao compilador Flex para
            procurar por variáveis de tempo de execução no arquivo
            <filename>services-config.xml</filename> que serão usadas pela classe
            <classname>RemoteObject</classname>
        </para>

        <para>
            Agora precisamos dizer ao Flex qual arquivo de configuração de serviços usar para
            conectar a nossos métodos remotos. Por essa razão crie um novo arquivo
            '<filename>services-config.xml</filename>' em seu diretório <filename>src</filename> do
            seu projeto Flex. Pra fazer isso clique com o botão direito no diretório do projeto e
            selecione 'new'; 'File' que uma nova janela se abrirá. Selecione o diretório do projeto
            e nomeie o arquivo '<filename>services-config.xml</filename>' e pressione 'finish'.
        </para>

        <para>
            O Flex criou um novo <filename>servies-config.xml</filename> e o abriu. Use o texto de
            exemplo a seguir para seu arquivo <filename>services-config.xml</filename>. Tenha
            certeza de atualizar seu ponto de extremidade (endpoint) para coincidir com seu servidor
            de testes e que você salve o arquivo.
        </para>

        <programlisting language="xml"><![CDATA[
<?xml version="1.0" encoding="UTF-8"?>
<services-config>
    <services>
        <service id="zend-service"
            class="flex.messaging.services.RemotingService"
            messageTypes="flex.messaging.messages.RemotingMessage">
            <destination id="zend">
                <channels>
                    <channel ref="zend-endpoint"/>
                </channels>
                <properties>
                    <source>*</source>
                </properties>
            </destination>
        </service>
    </services>
    <channels>
        <channel-definition id="zend-endpoint"
            class="mx.messaging.channels.AMFChannel">
            <endpoint uri="http://example.com/server.php"
                class="flex.messaging.endpoints.AMFEndpoint"/>
        </channel-definition>
    </channels>
</services-config>
]]></programlisting>

        <para>
            Há dois pontos chave no exemplo. Primeiro, mas por último na listagem, criamos um canal
            <acronym>AMF</acronym> e especificados o poonto de extremidade (endpoint) como
            <acronym>URL</acronym> para nosso <classname>Zend_Amf_Server</classname>:
        </para>

        <programlisting language="xml"><![CDATA[
<channel-definition id="zend-endpoint"
    <endpoint uri="http://example.com/server.php"
        class="flex.messaging.endpoints.AMFEndpoint"/>
</channel-definition>
]]></programlisting>

        <para>
            Note que demos a este canal um identificador, "zend-endpoint". O exemplo cria um destino
            de serviço que se refere a este canal, atribuindo a ele um ID também - neste caso
            "zend".
        </para>

        <para>
            Em nossos arquivos <acronym>MXML</acronym> do Flex, precisamos ligar um
            <classname>RemoteObject</classname> ao serviço. Em <acronym>MXML</acronym>, isto é feito
            como a seguir:
        </para>

        <programlisting language="xml"><![CDATA[
<mx:RemoteObject id="myservice"
    fault="faultHandler(event)"
    showBusyCursor="true"
    destination="zend">
]]></programlisting>

        <para>
            Aqui, definimos um novo objeto remoto identificado por "myservice" ligado ao destino de
            serviço "zend" que definimos no arquivo <filename>services-config.xml</filename>. Nós
            depois chamamos métodos em nosso ActionScript simplesmente
            chamando "myservice.&lt;método&gt;". Como no exemplo:
        </para>

        <programlisting language="ActionScript"><![CDATA[
myservice.hello("Wade");
]]></programlisting>

        <para>
            Quando usando espaços de nomes (namespaces), usamos:
            "myservice.&lt;espaço de nome&gt;.&lt;método&gt;":
        </para>

        <programlisting language="ActionScript"><![CDATA[
myservice.world.hello("Wade");
]]></programlisting>

        <para>
            Para mais informações sobre como utilizar o <classname>RemoteObject</classname> do Flex,
            <ulink url="http://livedocs.adobe.com/flex/3/html/help.html?content=data_access_4.html">
            visite o site da Ajuda do Adobre Flex 3</ulink>.
        </para>
    </sect2>

    <sect2 id="zend.amf.server.errors">
        <title>Manipulação de Erros</title>

        <para>
            Por padrão, todas as exceções lançadas em suas classes ou funções anexadas serão obtidas
            e retornadas como <classname>ErrorMessage</classname>s do <acronym>AMF</acronym>.
            No entando, o conteúdos destes objetos <classname>ErrorMessage</classname> variam se 
            o servidor está ou não em modo de "produção" (o estado padrão). 
        </para>

        <para>
            Quando em modo de produção, somente o código da exceção será retornado. Se você
            desabilitar o modo de produção - algo que você deve fazer apenas para testes - a maioria
            dos detalhes de exceção serão retornados: a mensagem de exceção, linha, e
            pilha de execução (backtrace) serão todos anexados.
        </para>

        <para>
            Para desabilitar o modo de produção, faça o seguinte:
        </para>

        <programlisting language="php"><![CDATA[
$server->setProduction(false);
]]></programlisting>

        <para>
            Para habilitá-lo novamnete, passe um valor booleano <constant>TRUE</constant>:
        </para>

        <programlisting language="php"><![CDATA[
$server->setProduction(true);
]]></programlisting>

        <note>
            <title>Desabilite o modo de produção com moderação!</title>

            <para>
                Recomendamos desabilitar o modo de produção somente durante o desenvolvimento.
                Mensagens de exceção e pilhas de execução podem conter informações sensíveis que
                você provavelmente não deseje que terceiros tenham acesso. Mesmo
                <acronym>AMF</acronym> sendo um formato binário, a especificação é aberta, o que
                quer dizer que qualquer um pode, potencialmente, desserializar os dados carregados.
            </para>
        </note>

        <para>
            Uma área para ser especialmente cuidadoso são os próprios erros <acronym>PHP</acronym>.
            Quando a diretiva <property>display_errors</property> do <acronym>INI</acronym> está
            habilitada, qualquer erro <acronym>PHP</acronym> para o nível atual de reltório de erros
            são mostrados diretamente na saída - potencialmente interrompendo a carga de dados
            <acronym>AMF</acronym>. Sugerimos desabilitar a diretiva
            <property>display_errors</property> em modo de produção para evitar tais problemas
        </para>
    </sect2>

    <sect2 id="zend.amf.server.response">
        <title>Respostas AMF</title>

        <para>
            Ocasionalmente você pode desejar manipular levemente o objeto de resposta, tipicamente
            para retornar cabeçalhos de mensagem extra. O método <methodname>handle()</methodname>
            do servidor retorna o objeto da resposta, possibilitando a você fazer isto.
        </para>

        <example id="zend.amf.server.response.messageHeaderExample">
            <title>Adicionando Cabeçalhos de Mensagem à Resposta AMF</title>

            <para>
                Neste exemplo, adicionamos um <classname>MessageHeader</classname> 'foo' com o
                valor 'bar' à resposta antes de retorná-la.
            </para>

            <programlisting language="php"><![CDATA[
$response = $server->handle();
$response->addAmfHeader(new Zend_Amf_Value_MessageHeader('foo', true, 'bar'))
echo $response;
]]></programlisting>
        </example>
    </sect2>

    <sect2 id="zend.amf.server.typedobjects">
        <title>Objetos Tipados</title>

        <para>
            De modo similar ao <acronym>SOAP</acronym>, <acronym>AMF</acronym> permite que sejam
            passados objetos entre o cliente e o servidor. Isso permite uma grande quantidade de
            flexibilidade e coerência entre os dois ambientes.
        </para>

        <para>
            <classname>Zend_Amf</classname> fornece três métodos para mapeamento entre objetos
            ActionScript e <acronym>PHP</acronym>.
        </para>

        <itemizedlist>
            <listitem>
                <para>
                    Primeiro, você deve criar explicitamente ligações no nível do servidor, usando o
                    método <methodname>setClassMap()</methodname>. O primeiro argumento é o nome da
                    classe ActionScript, o segundo é a classe <acronym>PHP</acronym> que a mapeia:
                </para>

                <programlisting language="php"><![CDATA[
// Mapeia a classe ActionScript 'ContactVO' para a classe PHP 'Contact':
$server->setClassMap('ContactVO', 'Contact');
]]></programlisting>
            </listitem>

            <listitem>
                <para>
                    Em segundo lugar, você definir a propriedade pública
                    <varname>$_explicitType</varname> em sua classe <acronym>PHP</acronym>, com o
                    valor representando a classe ActionScript para mapear:
                </para>

                <programlisting language="php"><![CDATA[
class Contact
{
    public $_explicitType = 'ContactVO';
}
]]></programlisting>
            </listitem>

            <listitem>
                <para>
                    Terceiro, de maneira similar, você pode definir o método público
                    <methodname>getASClassName()</methodname> em sua classe <acronym>PHP</acronym>;
                    este método deve retornar a classe ActionScript apropriada:
                </para>

                <programlisting language="php"><![CDATA[
class Contact
{
    public function getASClassName()
    {
        return 'ContactVO';
    }
}
]]></programlisting>
            </listitem>
        </itemizedlist>

        <para>
            Embora tenhamos criado o ContactVO no servidor precisamos agora fazer a classe
            correspondente em <acronym>AS3</acronym> para que o objeto de servidor seja mapeado.
        </para>
        
        <para>
            Clique com o botão direito na pasta <filename>src</filename> de seu projeto Flex e
            selecione 'New' -> 'ActionScript File'. Nomeie o arquivo como 'ContactVO' e pressione
            'finish' para ver o novo arquivo. Copie o seguinte código para finalizar a criação da
            classe.
        </para>

        <programlisting language="as"><![CDATA[
package
{
    [Bindable]
    [RemoteClass(alias="ContactVO")]
    public class ContactVO
    {
        public var id:int;
        public var firstname:String;
        public var lastname:String;
        public var email:String;
        public var mobile:String;
        public function ContactVO():void {
        }
    }
}
]]></programlisting>

        <para>
            A classe é sintaticamente equivalente à classe <acronym>PHP</acronym> com o mesmo nome.
            Os nomes de variáveis são exatamente os mesmos e precisam estar sob o mesmo caso para
            que funcione apropriadamente. Existem duas marcações meta (meta tags) 
            <acronym>AS3</acronym> únicas nesta classe. A primeira é Bindable, que faz com
            que um evento de alteração (change) seja disparado quando ela é atualizada. A segunda
            marcação é RemoteClass, que define que esta classe pode ter um objeto remoto mapeado a
            ela com um apelido, neste caso <emphasis>ContactVO</emphasis>. É obrigatório que o valor
            desta marcação seja definido seja estritamente equivalente ao da classe
            <acronym>PHP</acronym>.
        </para>

        <programlisting language="as"><![CDATA[
[Bindable]
private var myContact:ContactVO;

private function getContactHandler(event:ResultEvent):void {
    myContact = ContactVO(event.result);
}
]]></programlisting>

        <para>
            O evento de resultado gerado pela chamada ao serviço é instantaneamente convertido para
            o ContactVO do Flex. Qualquer coisa que seja direcionada a <varname>myContact</varname>
            será atualizado e os dados de ContactVO serão retornados.
        </para>
    </sect2>

    <sect2 id="zend.amf.server.resources">
        <title>Recursos</title>

        <para>
            <classname>Zend_Amf</classname> fornece ferramenta para mapear tipos de recursos
            retornados por classes de serviços em informações consumíveis pelo ActionScript.
        </para>

        <para>
            In order to handle specific resource type, the user needs to create a plugin class named
            after the resource name, with words capitalized and spaces removed (so, resource
            type "mysql result" becomes MysqlResult), with some prefix, e.g.
            <classname>My_MysqlResult</classname>. This class should implement one method,
            <methodname>parse()</methodname>, receiving one argument - the resource - and returning
            the value that should be sent to ActionScript. The class should be located in the file
            named after the last component of the name, e.g. <filename>MysqlResult.php</filename>.
        </para>

        <para>
            The directory containing the resource handling plugins should be registered with
            <classname>Zend_Amf</classname> type loader:
        </para>

        <programlisting language="php"><![CDATA[
Zend_Amf_Parse_TypeLoader::addResourceDirectory(
    "My",
    "application/library/resources/My"
);
]]></programlisting>

        <para>
            For detailed discussion of loading plugins, please see
            the <link linkend="zend.loader.pluginloader">plugin loader</link> section.
        </para>

        <para>
            Default directory for <classname>Zend_Amf</classname> resources is registered
            automatically and currently contains handlers for "mysql result" and "stream"
            resources.
        </para>

        <programlisting language="php"><![CDATA[
// Example class implementing handling resources of type mysql result
class Zend_Amf_Parse_Resource_MysqlResult
{
    /**
     * Parse resource into array
     *
     * @param resource $resource
     * @return array
     */
    public function parse($resource) {
        $result = array();
        while($row = mysql_fetch_assoc($resource)) {
            $result[] = $row;
        }
        return $result;
    }
}
]]></programlisting>

        <para>
            Trying to return unknown resource type (i.e., one for which no handler plugin exists)
            will result in an exception.
        </para>
    </sect2>

    <sect2 id="zend.amf.server.flash">
        <title>Connecting to the Server from Flash</title>

        <para>
            Connecting to your <classname>Zend_Amf_Server</classname> from your Flash project is
            slightly different than from Flex. However once the connection Flash functions with
            <classname>Zend_Amf_Server</classname> the same way is flex. The following example can
            also be used from a Flex <acronym>AS3</acronym> file. We will reuse the same
            <classname>Zend_Amf_Server</classname> configuration along with the World class for our
            connection.
        </para>

        <para>
            Open Flash CS and create and new Flash File (ActionScript 3). Name the document
            <filename>ZendExample.fla</filename> and save the document into a folder that you will
            use for this example. Create a new <acronym>AS3</acronym> file in the same directory
            and call the file <filename>Main.as</filename>. Have both files open in your editor. We
            are now going to connect the two files via the document class. Select ZendExample and
            click on the stage. From the stage properties panel change the Document class to Main.
            This links the <filename>Main.as</filename> ActionScript file with the user interface
            in <filename>ZendExample.fla</filename>. When you run the Flash file ZendExample the
            <filename>Main.as</filename> class will now be run. Next we will add ActionScript to
            make the <acronym>AMF</acronym> call.
        </para>

        <para>
            We now are going to make a Main class so that we can send the data to the server and
            display the result. Copy the following code into your <filename>Main.as</filename> file
            and then we will walk through the code to describe what each element's role is.
        </para>

        <programlisting language="as"><![CDATA[
package {
  import flash.display.MovieClip;
  import flash.events.*;
  import flash.net.NetConnection;
  import flash.net.Responder;

  public class Main extends MovieClip {
    private var gateway:String = "http://example.com/server.php";
    private var connection:NetConnection;
    private var responder:Responder;

    public function Main() {
      responder = new Responder(onResult, onFault);
      connection = new NetConnection;
      connection.connect(gateway);
    }

    public function onComplete( e:Event ):void{
      var params = "Sent to Server";
      connection.call("World.hello", responder, params);
    }

    private function onResult(result:Object):void {
      // Display the returned data
      trace(String(result));
    }
    private function onFault(fault:Object):void {
      trace(String(fault.description));
    }
  }
}
]]></programlisting>

        <para>
            We first need to import two ActionScript libraries that perform the bulk of the work.
            The first is NetConnection which acts like a by directional pipe between the client and
            the server. The second is a Responder object which handles the return values from the
            server related to the success or failure of the call.
        </para>

        <programlisting language="as"><![CDATA[
import flash.net.NetConnection;
import flash.net.Responder;
]]></programlisting>

        <para>
            In the class we need three variables to represent the NetConnection, Responder, and
            the gateway <acronym>URL</acronym> to our <classname>Zend_Amf_Server</classname>
            installation.
        </para>

        <programlisting language="as"><![CDATA[
private var gateway:String = "http://example.com/server.php";
private var connection:NetConnection;
private var responder:Responder;
]]></programlisting>

        <para>
            In the Main constructor we create a responder and a new connection to the
            <classname>Zend_Amf_Server</classname> endpoint. The responder defines two different
            methods for handling the response from the server. For simplicity I have called these
            onResult and onFault.
        </para>

        <programlisting language="as"><![CDATA[
responder = new Responder(onResult, onFault);
connection = new NetConnection;
connection.connect(gateway);
]]></programlisting>

        <para>
            In the onComplete function which is run as soon as the construct has completed we send
            the data to the server. We need to add one more line that makes a call to the
            <classname>Zend_Amf_Server</classname> World->hello function.
        </para>

        <programlisting language="as"><![CDATA[
connection.call("World.hello", responder, params);
]]></programlisting>

        <para>
            When we created the responder variable we defined an onResult and onFault function to
            handle the response from the server. We added this function for the successful result
            from the server. A successful event handler is run every time the connection is handled
            properly to the server.
        </para>

        <programlisting language="as"><![CDATA[
private function onResult(result:Object):void {
    // Display the returned data
    trace(String(result));
}
]]></programlisting>

        <para>
            The onFault function, is called if there was an invalid response from the server. This
            happens when there is an error on the server, the <acronym>URL</acronym> to the server
            is invalid, the remote service or method does not exist, and any other connection
            related issues.
        </para>

        <programlisting language="as"><![CDATA[
private function onFault(fault:Object):void {
    trace(String(fault.description));
}
]]></programlisting>

        <para>
            Adding in the ActionScript to make the remoting connection is now complete. Running the
            ZendExample file now makes a connection to <classname>Zend_Amf</classname>. In review
            you have added the required variables to open a connection to the remote server, defined
            what methods should be used when your application receives a response from the server,
            and finally displayed the returned data to output via <methodname>trace()</methodname>.
        </para>
    </sect2>

    <sect2 id="zend.amf.server.auth">
        <title>Authentication</title>

        <para>
            <classname>Zend_Amf_Server</classname> allows you to specify authentication and
            authorization hooks to control access to the services. It is using the infrastructure
            provided by <link linkend="zend.auth"><classname>Zend_Auth</classname></link> and
            <link linkend="zend.acl"><classname>Zend_Acl</classname></link> components.
        </para>

        <para>
            In order to define authentication, the user provides authentication adapter extening
            <classname>Zend_Amf_Auth_Abstract</classname> abstract class. The adapter should
            implement the <methodname>authenticate()</methodname> method just like regular
            <link linkend="zend.auth.introduction.adapters">authentication adapter</link>.
        </para>

        <para>
            The adapter should use properties <emphasis>_username</emphasis> and
            <emphasis>_password</emphasis> from the parent
            <classname>Zend_Amf_Auth_Abstract</classname> class in order to authenticate. These
            values are set by the server using <methodname>setCredentials()</methodname> method
            before call to <methodname>authenticate()</methodname> if the credentials are received
            in the <acronym>AMF</acronym> request headers.
        </para>

        <para>
            The identity returned by the adapter should be an object containing property
            <property>role</property> for the <acronym>ACL</acronym> access control to work.
        </para>

        <para>
            If the authentication result is not successful, the request is not proceseed further
            and failure message is returned with the reasons for failure taken from the result.
        </para>

        <para>
            The adapter is connected to the server using <methodname>setAuth()</methodname> method:
        </para>

        <programlisting language="php"><![CDATA[
$server->setAuth(new My_Amf_Auth());
]]></programlisting>

        <para>
            Access control is performed by using <classname>Zend_Acl</classname> object set by
            <methodname>setAcl()</methodname> method:
        </para>

        <programlisting language="php"><![CDATA[
$acl = new Zend_Acl();
createPermissions($acl); // create permission structure
$server->setAcl($acl);
]]></programlisting>

        <para>
            If the <acronym>ACL</acronym> object is set, and the class being called defines
            <methodname>initAcl()</methodname> method, this method will be called with the
            <acronym>ACL</acronym> object as an argument. The class then can create additional
            <acronym>ACL</acronym> rules and return <constant>TRUE</constant>, or return
            <constant>FALSE</constant> if no access control is required for this class.
        </para>

        <para>
            After <acronym>ACL</acronym> have been set up, the server will check if access is
            allowed with role set by the authentication, resource being the class name (or
            <constant>NULL</constant> for
            function calls) and privilege being the function name. If no authentication was
            provided, then if the <emphasis>anonymous</emphasis> role was defined, it will be used,
            otherwise the access will be denied.
        </para>

        <programlisting language="php"><![CDATA[
if($this->_acl->isAllowed($role, $class, $function)) {
    return true;
} else {
    require_once 'Zend/Amf/Server/Exception.php';
    throw new Zend_Amf_Server_Exception("Access not allowed");
}
]]></programlisting>
    </sect2>
</sect1>
<!--
vim:se ts=4 sw=4 et:
-->
